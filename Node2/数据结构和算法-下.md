# 数据结构和算法（下）

------



## 一、求一个二叉搜索树的第 k 小值

<img src="https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/image-20220303102030421.png" alt="image-20220303102030421" style="zoom:45%;" />

### 1. 前置知识

+ 二叉树（ Binary Tree ）
  1. 是一颗树
  2. 每个节点最多有两个子节点
  3. 树节点的数据格式 `{ value, left?, right? }`
+ 二叉树的遍历
  1. 前序遍历：**root** -> left -> right
  2. 中序遍历：left -> **root** -> right
  3. 后序遍历：left -> right -> **root**
+ 二叉搜索树 BST ( Binary Search Tree )
  1. left ( 包括其后代 ) value <= root value
  2. right ( 包括其后代 ) value >= root value
  3. 可使用 **二分法** 进行快速查找

### 2. 代码演示

```typescript
interface TreeNode {
    value: number,
    left: TreeNode | null,
    right: TreeNode | null
}

const bst: TreeNode = {
    value: 5,
    left: {
        value: 3,
        left: {
            value: 2,
            left: null,
            right: null
        },
        right: {
            value: 4,
            left: null,
            right: null
        }
    },
    right: {
        value: 7,
        left: {
            value: 6,
            left: null,
            right: null
        },
        right: {
            value: 8,
            left: null,
            right: null
        }
    }
}

/**
 * 二叉树前序遍历
 * @param node node
 */
// 5 3 2 4 7 6 8
function preOrderTraverse(node: TreeNode | null) {
    if (node == null) return
    console.log(node.value)
    preOrderTraverse(node.left)
    preOrderTraverse(node.right)
}

/**
 * 二叉树中序遍历
 * @param node node
 */
// 2 3 4 5 6 7 8
function inOrderTraverse(node: TreeNode | null) {
    if (node == null) return
    inOrderTraverse(node.left)
    console.log(node.value)
    inOrderTraverse(node.right)
}

/**
 * 二叉树后序遍历
 * @param node node
 */
// 2 4 3 6 8 7 5
function postOrderTraverse(node: TreeNode | null) {
    if (node == null) return
    postOrderTraverse(node.left)
    postOrderTraverse(node.right)
  	console.log(node.value)
}
```

### 3. 解题思路

+ BST 中序遍历，即从小到大的排序
+ 找到排序后的第 k 值即可

![image-20220304142018947](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/image-20220304142018947.png)

### 4. 代码

```typescript
const array: number[] = []

/**
 * 二叉树中序遍历
 * @param node node
 */
function inOrderTraverse(node: TreeNode | null) {
    if (node == null) return
    inOrderTraverse(node.left)
    array.push(node.value)
    inOrderTraverse(node.right)
}

/**
 * 寻找 BST 里的第 k 小值
 * @param node node
 * @param k k
 */
function getKthValue(node: TreeNode, k: number): number | null {
    inOrderTraverse(node)
    return array[k - 1] || null
}
```

### 5. 单元测试

```typescript
/**
 * @description 二叉搜索树第 k 小值
 * @author lzz
 */

import {bst, getKthValue} from "./8.求一个二叉搜索树的第 k 小值";

describe('二叉搜索树第 k 小值', () => {
    it('正常情况', () => {
        expect(getKthValue(bst, 3)).toBe(4)
    });

    it('k 不在正常范围之内', () => {
        expect(getKthValue(bst, 0)).toBeNull()
      	expect(getKthValue(bst, 100)).toBeNull()
    });
})
```

### 6. 划重点

+ 二叉树，和三种（前序、中序、后序）遍历
+ 二叉搜索树的特点：left <= root; right >= root
+ 二叉搜索树的价值：可使用 **二分法** 进行快速查找

------



## 二、为何二叉树如此重要，而不是其他叉树

### 1. 性能、性能还是性能

+ 数组：查询快 O(1)，增删慢 O(n)
+ 链表：查询慢 O(n)，增删快 O(1)
+ 二叉搜索树 BST：查询快，增删快 -- “ 木桶效应 ”

### 2. 平衡二叉树

+ BST 如果不平衡，那就又成了链表了
+ 所有要尽量平衡：平衡二叉搜索树 BBST
+ BBST 增删查，时间复杂度都是 O(logn)，即树的高度

### 3. 红黑树

+ 一种自平衡二叉树
+ 分为 红/黑 两种颜色，通过颜色转换来维持树的平衡
+ 相对于普通平衡二叉树，它维持平衡的效率更高

### 4. B 树

+ 物理上是多叉树，但逻辑上是二叉树
+ 一般用于高效 I/O，关系型数据库常用于 B树来组织数据

### 5. 小结

+ 数组、链表，各有各的缺点
+ 特定的二叉树（ BBST ）可以让整体效果最优
+ 各种高级二叉树，继续优化，满足不同场景

------



## 三、堆有什么特点，和二叉树有什么关系

### 1. 堆栈模型

+ JS 代码执行时
+ 值类型变量，存储在栈
+ 引用类型变量，存储在堆

### 2. 堆

+ 完全二叉树
+ 最大堆：父节点 >= 子节点
+ 最小堆：父节点 <= 子节点

![image-20220304155216716](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/image-20220304155216716.png)

![image-20220304155342072](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/image-20220304155342072.png)

### 3. 逻辑结构 vs 物理结构

+ 堆，**逻辑结构** 是一棵二叉树
+ 但它 **物理结构** 是一个数组
+ 数组：适合连续存储 + 节省空间（ 回顾堆栈模型 ）

### 4. 堆 vs BST

+ 查询比 BST 慢
+ 增删比 BST 快，维持平衡更快
+ 但整体的时间复杂度都在 O(logn) 级别，即树的高度

### 5. 堆的使用场景

+ 特别适合 “ 堆栈模型 ”
+ 堆的数据，都是在栈中引用的，不需要从 root 遍历
+ 堆恰巧是数组形式，根据栈的地址，可用 O(1) 找到目标

### 6. 小结

+ 堆栈模型，堆的场景
+ 堆的特点，堆和 BST
+ 堆的逻辑结构和物理结构

------



## 四、求斐波那契数列第 n 个值

### 1. 题目

+ 用 JS 计算斐波那契数列的第 n 个值
+ 注意时间复杂度

### 2. 解题思路

+ f(0) = 0
+ f(1) = 1
+ f(n) = f(n - 1) + f(n - 2)

### 3. 代码（递归，不可用）

```typescript
/**
 * @description 求斐波那契数列第 n 个值
 * @author lzz
 */

/**
 * 斐波那契数列第 n 个值（递归）
 * @param n
 */
function fibonacci(n: number): number {
    if (n <= 0) return 0
    if (n === 1) return 1
    return fibonacci(n - 1) + fibonacci(n - 2)
}
```

### 4. 分析

+ 递归 - 大量的重复计算！
+ 时间复杂度是 O(2^n)

![image-20220304165030268](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/image-20220304165030268.png)

### 5. 优化

+ 不用递归，用循环
+ 记录中间结果
+ 时间复杂度为 O(n)

### 6. 代码（循环）

```typescript
/**
 * 斐波那契数列第 n 个值 (循环)
 * @param n
 */
function fibonacci(n: number): number {
    if (n <= 0) return 0
    if (n === 1) return 1
    let n1 = 1  // 记录 n - 1 的结果
    let n2 = 0  // 记录 n - 2 的结果
    let res = 0
    // 要从 2 开始循环
    for (let i = 2; i <= n; i++) {
        res = n1 + n2
        // 记录中间结果
        n2 = n1
        n1 = res
    }
    return res
}
```

### 7. 单元测试

```typescript
/**
 * @description 求斐波那契数列的第n值
 * @author lzz
 */

import {fibonacci} from './9.求斐波那契数列的第n值'

describe('求斐波那契数列的第n值', () => {
    it('0 和 1', function () {
        expect(fibonacci(0)).toBe(0)
        expect(fibonacci(1)).toBe(1)
    });
    it('除 0 和 1 外, 正常情况', function () {
        expect(fibonacci(9)).toBe(34)
    });
    it('n 小于 0', function () {
        expect(fibonacci(-1)).toBe(0)
    });
})
```

### 8. 动态规划

+ 把一个大问题，拆解成多个小问题，逐级向下拆解
+ 用递归的思路去分析问题，再改为循环来实现
+ 算法三大思维：贪心、二分、动态规划

------



## 五、（连环问）青蛙跳台阶有几种方式

### 1. 题目

+ 一只青蛙，一次可以跳 1 级，也可以跳 2 级
+ 问：青蛙跳到 n 级台阶，总共有多少种方式？

### 2. 用动态规划分析问题

+ 要跳到 1 级台阶，就 1 种方式 f(1) = 1
+ 要跳到 2 级台阶，就 2 种方式 f(2) = 2
+ 要跳到 n 级台阶，f(n) = f(n - 1) + f(n - 2)

![iShot2022-03-04 17.40.47](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/iShot2022-03-04%2017.40.47.jpg)

+ 和斐波那契数列完全一样

