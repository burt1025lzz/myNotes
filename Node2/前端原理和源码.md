# 前端原理和源码

------



## 一、JS 内存泄漏如何检测？场景？

### 1. 垃圾回收 GC

+ 什么是垃圾回收？

+ 引用计数（之前）

  ```js
  // 对象被 a 引用
  let a = {
    	x: 100
  }
  let a1 = a
  a = 10
  a1 = null  // 此时 { x: 100 } 被引用次数为 0 ，就会被清除
  
  // 缺陷：循环引用会有问题
  function fn() {
      const obj1 = {}
      const obj2 = {}
      obj1.a = obj2
      obj2.a = obj1
  }
  fn()
  
  // IE6-7 内存泄露 BUG
  var div = document.getElementById('div')
  div.a = div
  div.someBigData = {}
  ```

+ 标记清除（现代）

  1. 会定时从 JS 根 window 开始逐步向下遍历，如果引用不到就会清除

### 2. ( 连环问 ) 闭包算内存泄漏吗？

+ 不算，属于用户期望，但是垃圾回收不掉

### 3. 内存泄漏检测方法

+ 可使用 Chrome Performance 检测

  1. 泄漏结果

     ![image-20220316155504373](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/image-20220316155504373.png)

  2. 正常结果

     ![image-20220316155945765](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/image-20220316155945765.png)

### 4. 内存泄漏场景（Vue 为例）

+ 被全局变量、函数引用，组件销毁时未清除
+ 被全局事件、定时器引用，组件销毁时未清除
+ 被自定义事件引用，组件销毁时未清除

### 5. 划重点

+ 前几年前端不太注重内存泄漏，因为不像后端 7*24 持续运行
+ 近几年前端功能变得复杂，内存问题也要重点考虑

### 6. 扩展：WeakMap WeakSet

```js
const wMap = new WeakMap()  // 弱引用
function fn() {
  	const obj = { x: 100 }
    wMap.set(obj, 100)  // weakMap 的 key 只能是引用类型
}
fn()
```

------

