# 前端原理和源码

------



## 一、JS 内存泄漏如何检测？场景？

### 1. 垃圾回收 GC

+ 什么是垃圾回收？

+ 引用计数（之前）

  ```js
  // 对象被 a 引用
  let a = {
    	x: 100
  }
  let a1 = a
  a = 10
  a1 = null  // 此时 { x: 100 } 被引用次数为 0 ，就会被清除
  
  // 缺陷：循环引用会有问题
  function fn() {
      const obj1 = {}
      const obj2 = {}
      obj1.a = obj2
      obj2.a = obj1
  }
  fn()
  
  // IE6-7 内存泄露 BUG
  var div = document.getElementById('div')
  div.a = div
  div.someBigData = {}
  ```

+ 标记清除（现代）

  1. 会定时从 JS 根 window 开始逐步向下遍历，如果引用不到就会清除

### 2. ( 连环问 ) 闭包算内存泄漏吗？

+ 不算，属于用户期望，但是垃圾回收不掉

### 3. 内存泄漏检测方法

+ 可使用 Chrome Performance 检测

  1. 泄漏结果

     ![image-20220316155504373](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/image-20220316155504373.png)

  2. 正常结果

     ![image-20220316155945765](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/image-20220316155945765.png)

### 4. 内存泄漏场景（Vue 为例）

+ 被全局变量、函数引用，组件销毁时未清除
+ 被全局事件、定时器引用，组件销毁时未清除
+ 被自定义事件引用，组件销毁时未清除

### 5. 划重点

+ 前几年前端不太注重内存泄漏，因为不像后端 7*24 持续运行
+ 近几年前端功能变得复杂，内存问题也要重点考虑

### 6. 扩展：WeakMap WeakSet

```js
const wMap = new WeakMap()  // 弱引用
function fn() {
  	const obj = { x: 100 }
    wMap.set(obj, 100)  // weakMap 的 key 只能是引用类型
}
fn()
```

------



## 二、浏览器和 nodejs 事件循环区别

### 1. 单线程和异步

+ JS 是单线程的（无论在浏览器还是 nodejs）
+ 浏览器中 JS 执行和 DOM 渲染共用一个线程
+ 异步

### 2. 宏任务和微任务

+ 宏任务，如 setTimeout setInterval 网络请求
+ 微任务，如 Promise async / await
+ 微任务在下一轮 DOM 渲染之前执行，宏任务在之后执行

### 3. 浏览器 event loop

![image-20220317100749714](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/image-20220317100749714.png)

+ Callback Queue 分为
  1. 宏任务队列 MarcoTask Queue
  2. 微任务队列 MicroTask Queue

### 4. nodejs 异步

+ Nodejs 同样适用 ES 语法，也是单线程，也需要异步
+ 异步任务也分：宏任务 + 微任务
+ 但是，它的宏任务和微任务，分为不同类型，有不同优先级

### 5. nodejs 宏任务类型和优先级

+ Timers - setTimeout setInterval
+ I/O callbacks - 处理网络、流、TCP 的错误回调
+ Idle，prepare - 闲置状态（nodejs 内部使用）
+ Poll 轮询 - 执行 poll 中的 I/O 队列
+ Check 检查 - 存储 setImmediate 回调
+ Close callbacks - 关闭回调，如 socket.on('close')

### 6. nodejs 微任务类型和优先级

+ 包括：promise，async / await，process.nextTick
+ 注意，process.nextTick 优先级最高

### 7. nodejs event loop

+ 执行同步代码

+ 执行微任务（process.nextTick 优先级更高）

+ 按顺序执行 6 个类型的宏任务（每个结束时都执行当前的微任务）

  ![image-20220317103505024](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/image-20220317103505024.png)

### 8. 答案

+ 浏览器和 nodejs 的 event loop 流程基本相同
+ nodejs 宏任务和微任务分类型，有优先级

### 9. 注意事项

+ 推荐使用 setImmediate 代替 process.nextTick

------



## 三、虚拟 vdom 真的很快吗

### 1. vdom

+ Virtual DOM ，虚拟 DOM
+ 用 JS 对象模拟 DOM 节点数据
+ 由 React 最先推广使用

### 2. Vue React 等框架的价值

+ 组件化
+ 数据视图分离，数据驱动视图 -- 这是核心！
+ 只关注业务数据，而不用再关心 DOM 变化

### 3. 答案

+ vdom 并不快，JS 直接操作 DOM 才最快
+ 但 “ 数据驱动视图 ” 要有合适的技术方案，不能全部 DOM 重建
+ vdom 就是目前最合适的技术方案（并不是因为它快，而是合适）

------



## 四、遍历一个数组用 for 和 forEach 哪个快

### 1. 代码

```js
const arr = []
for (let i = 0; i < 100 * 10000; i++) {
    arr.push(i)
}

console.time('for')
let n = 0
for (let i = 0; i < arr.length; i++) {
    n++
}
console.timeEnd('for')  // 3.48ms

console.time('forEach')
let m = 0
arr.forEach(() => m++)
console.timeEnd('forEach')  // 14.13ms
```

### 2. 答案

+ for 更快
+ forEach 每次都要创建一个函数来调用，而 for 不会创建函数
+ 函数需要独立的作用域，会有额外的开销

### 3. 划重点

+ 越 “ 低级 ” 的代码，性能往往越好
+ 日常开发别只考虑性能，forEach 代码可读性更好
+ 类似之前算法文档中：循环 vs 递归

------

