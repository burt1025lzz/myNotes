# 从前端到全栈

------



## 一、如何解决移动端 H5 点击有 300ms 延迟

### 1. 背景

+ double tap to zoom

### 2. 初期解决方案 FastClick

```js
window.addEventListener("load", function() {
  	FastClick.attach(document.body)
}, false)
```

### 3. FastClick 原理

+ 监听 touchend 事件（ touchstart touchend 会先于 click 触发 ）
+ 使用 **自定义 DOM 事件** 模拟一个 click 事件
+ 把默认的 click 事件（ 300ms 之后触发）禁止掉

### 4. 现代浏览器的改进

![image-20220321170114819](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/image-20220321170114819.png)

------



## 二、token 和 cookie 有什么区别

### 1. cookie

+ HTTP 无状态，每次请求都要带 cookie ，以帮助识别身份
+ 服务端也可以向客户端 set-cookie ，cookie 大小限制 4kb
+ 默认有跨域限制：不可跨域共享、传递 cookie

### 2. cookie 本地存储

+ HTML5 之前 cookie 常被用于本地存储
+ HTML5 之后推荐使用 localStorage 和 sessionStorage

### 3. 现代浏览器开始禁止第三方 cookie

+ 和跨域限制不同。这里指：禁止网页引入的第三方 JS 设置 cookies

+ 打击第三方广告，保护用户隐私

+ 新增属性 SameSite: Strict / Lax / None; 值可自己选择

  ![image-20220321174346925](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/image-20220321174346925.png)

### 4. cookie 和 session

+ cookie 用于登录校验，存储用户标识（如 userId）

+ session 在服务端，存储用户详细信息，和 cookie 信息一一对应

+ cookie + session 是常用的登录验证解决方案

  ![image-20220321175050647](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/image-20220321175050647.png)

### 5. token 和 cookie

+ cookie 是 HTTP 规范，而 token 是自定义传递
+ cookie 会默认被浏览器存储，而 token 需自己存储
+ token 默认没有跨域限制

### 6. JWT ( JSON Web Token )

+ 前端发起登录，后端验证成功之后，返回一个加密的 token

+ 前端自行存储这个 token（其中包括了用户信息，加密了）

+ 以后访问服务端接口，都带着这个 token ，作为用户信息

  ![image-20220322095235987](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/image-20220322095235987.png)

### 7. 答案

+ cookie：HTTP 标准；跨域限制；配合 session 使用
+ token：无标准，无跨域限制；用于 JWT

### 8. 划重点

+ cookie 的知识点很多，对于 HTTP 也很重要
+ Session 存在的价值
+ token 和 cookie 要对比理解，否则容易混淆

### 9. ( 连环问 ) Session 和 JWT 哪个更好

+ Session 优点
  1. 原理简单，易于学习
  2. 用户信息存储在服务端，可快速封禁某个用户
+ Session 缺点
  1. 占用服务器内存，硬件成本高
  2. 多进程，多服务器时，不好同步 -- 需使用第三方缓存，如 redis
  3. 默认有跨域限制
+ JWT 优点
  1. 不占用服务端内存
  2. 多进程、多服务器，不受影响
  3. 没有跨域限制
+ JWT 缺点
  1. 用户信息存储在客户端，无法快速封禁某用户
  2. 万一服务端秘钥被泄露，则用户信息全部丢失
  3. token 体积一般大于 cookie ，会增加请求的数据量
+ 答案
  1. 如有严格管理用户信息的需求（保密、快速封禁）推荐 Session
  2. 如没有特殊要求，则使用 JWT （如创业初期的网站）

### 10. ( 连环问 ) 如何实现 SSO 单点登录

+ 基于 cookie

  1. cookie 默认不可跨域共享，但有些情况下可设置为共享
  2. 主域名相同，如 `www.baidu.com` `image.baidu.com`
  3. 设置 cookie domain 为主域名，即可共享 cookie

+ SSO

  1. 主域名完全不同，则 cookie 无法共享

  2. 可使用 SSO 技术方案

     ![iShot2022-03-22 10.41.01](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/iShot2022-03-22%2010.41.01.jpg)

+ OAuth 2.0

  ![image-20220322104429670](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/image-20220322104429670.png)

------



## 三、HTTP 协议和 UDP 协议区别

### 1. 网络协议

+ HTTP 协议在应用层

+ TCP UDP 协议在传输层

+ 严格来说，应该拿 TCP 和 UDP 进行比较

  ![image-20220322142418277](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/image-20220322142418277.png)

### 2. TCP 协议

+ 有连接（三次握手）
+ 有断开（四次挥手）
+ 稳定传输

### 3. UDP 协议

+ 无连接，无断开
+ 不稳定传输，但效率高
+ 适用视频会议，语音通话

### 4. ( 连环问 ) HTTP 协议 1.0 1.1 2.0 有什么区别

+ HTTP 1.0
  1. 最基础的 HTTP 协议
  2. 支持基本的 GET POST 方法
+ HTTP 1.1
  1. 缓存策略 cache-control E-tag 等
  2. 支持长连接 Connection: keep-alive ，一次 TCP 连接多次请求
  3. 断点续传，状态码 206
  4. 支持新的方法 PUT DELETE 等，可用于 Restful API
+ HTTP 2.0
  1. 可压缩 header ，减少体积
  2. 多路复用，一次 TCP 连接中可以多个 HTTP 并行请求
  3. 服务端推送

------



## 四、WebSocket 和 HTTP 有什么区别

### 1. WebSocket

+ 支持端对端通讯
+ 可以由 client 发起，也可以由 server 发起
+ 用于：消息通知，直播间讨论区，聊天室，协同编辑

### 2. 代码

```js
// 客户端 html
const ws = new WebSocket('ws://localhost:3001')
ws.onopen = () => {
  console.log('opened')
  ws.send('client opened')
}
ws.onmessage = ev => {
  console.log('客户端收到了信息', ev.data)
}
```

```js
// 服务端 nodejs
const {WebSocketServer} = require('ws')

const wsServer = new WebSocketServer({port: 3001})

wsServer.on('connection', ws => {
  console.log('connected')

  ws.on('message', msg => {
    console.log('收到了信息', msg.toString())

    // 服务端像客户端发送信息
    setTimeout(() => {
      ws.send('服务端收到了信息' + msg.toString())
    }, 2000)
  })
})
```

### 3. WebSocket 连接过程

+ 先发起一个 HTTP 请求
+ 成功之后再升级到 WebSocket 协议，再通讯

### 4. WebSocket 和 HTTP 区别

+ WebSocket 协议名是 ws:// ，可 **双端** 发起请求
+ WebSocket 没有跨域限制
+ 通过 send 和 onmessage 通讯（HTTP 通过 req 和 res）

### 5. ws 可升级为 wss （像 https）

```js
import {createServer} from 'https'
import {readFileSync} from 'fs'
import {WebSocketServer} from 'ws'

const server = createServer({
  cert: readFileSync('/path/to/cert.pem'),
  key: readFileSync('/path/to/key.pem')
})
const wss = new WebSocketServer({server})
```

### 6. 扩展：实际项目推荐 socket.io ，API 更简洁

```js
io.on('connection', socket => {
  // emit an event to the socket
  socket.emit('request', '...')
  // emit an event to all connected sockets
  io.emit('broadcast', '...')
  // listen to the event
  socket.on('reply', () => { /* ... */ })
})
```

### 7. 扩展：创建简易聊天室

```js
// nodejs
const {WebSocketServer} = require('ws')

const wsServer = new WebSocketServer({port: 3001})
const list = new Set()
wsServer.on('connection', curWs => {
  console.log('connected')

  // 这里不能一直 add , 实际中这里应该有清理缓存的机制
  list.add(curWs)
  curWs.on('message', msg => {
    console.log('收到了信息', msg.toString())
    // 传递给其他客户端
    list.forEach(ws => {
      if (ws === curWs) return
      ws.send(msg.toString())
    })
  })
})
```

### 8. ( 连环问 ) WebSocket 和 HTTP 长轮询的区别

+ HTTP 长轮询：客户端发起请求，服务端阻塞，不会立即返回

+ WebSocket：客户端可发起请求，服务端也可发起请求

+ HTTP 长轮询，需处理 timeout ，即 timeout 之后重新请求

  ![image-20220322165000190](https://burt-markdown.oss-cn-shenzhen.aliyuncs.com/markdown/image-20220322165000190.png)

------

